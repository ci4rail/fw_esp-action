name: "ESP Firmware Build Bootloader Action"
description: "Build ESP bootloader using the devcontainer used in the project"
inputs:
  builder-image:
    description: "Docker image name"
    required: true

runs:
  using: "composite"
  steps:
    - name: Get project and filename
      shell: bash
      id: identify
      env:
        EVENT_NAME: ${{ github.event_name }}
      run: |
        project=$(grep -m1 -o 'project([^)]*)' CMakeLists.txt | sed 's/project(\(.*\))/\1/')
        echo "project=$(echo ${project})" >> $GITHUB_OUTPUT
    - name: Build bootloader
      shell: bash
      id: build
      # Build firmware using same docker image as used in devcontainer or gitpod to have exactly same environment as for local builds
      run: |
        build_cmd="source /opt/esp/idf/export.sh && cd /src/ && git config --global --add safe.directory /src && make bootloader"
        echo "calling build container with command: ${build_cmd}"

        docker run -v $(pwd):/src ${{ inputs.builder-image }} bash -c "${build_cmd}"

        sudo chown -R runner .
        version=$(awk 'match($0,/PROJECT_VER=\\"[\.a-z0-9\-]+\\"/) { print substr($0,RSTART+14,RLENGTH-16)}' build/build.ninja)
        project=${{ steps.identify.outputs.project }}
        blfile=${project}-bootloader-${version}.bin
        cp build/bootloader/bootloader.bin build/bootloader/${blfile}

        echo "version=${version}" >> $GITHUB_OUTPUT
        echo "bootloader-file=build/bootloader/${blfile}" >> $GITHUB_OUTPUT

outputs:
  project-name:
    description: "Project name"
    value: ${{ steps.identify.outputs.project }}
  version:
    description: "Bootloader version"
    value: ${{ steps.build.outputs.version }}
  bootloader-file:
    description: "Bootloader file name"
    value: ${{ steps.build.outputs.bootloader-file }}